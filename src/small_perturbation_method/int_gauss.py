# -*- coding: utf-8 -*-
"""int_gauss.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wKt5SNP5ljD1OP7iKnMlnpPgO7pGsqpx
"""



### RUTINA DE INTEGRACION GAUSSIANA ###

# \int^{k_lim}_{-k_lim} dy \int^{k_lim}_{-k_lim} dx f(x,y) =
      # = k_lim**2 \Sum^n_{j=1} \Sum^n_{k=1} W_{jk} f(x_j,y_k)  

## Entrada: 
          # n = nro de nodos para pesos W_jk y puntos de muestra en f(x,y)
          # k_lim = limite de las integrales

  
## Salida:
          # W_jk : pesos para la integración
          # [X_IG,Y_IG] = mesh para evaluar a la función f(x,y)
          # m_gauss = parámetro para reformatear la salida y sumar

##------------Integracion gaussiana---------------##
import numpy as np

def int_gauss(n,k_lim):

  beta = np.zeros(n,dtype=float)

  for k in range(1,n+1):
    beta[k-1] = 0.5/np.sqrt(1-(2*(k))**(-2))

  m = n+1
  T_low = np.zeros((m,m))
  T_up = np.zeros((m,m))
  T = np.zeros((m,m))

  # defino T_low
  for i in range(0,m):
      for j in range(0,m):
          if i==j+1:
              T_low[i,j]=beta[i-1]
  # defino T_up
  for i in range(0,m):
      for j in range(0,m):
          if j==i+1:
              T_up[i,j]=beta[i]

  T = T_low + T_up        
  d_,V = np.linalg.eig(T)
  D = np.zeros((m,m))

  for i in range(0,m):
      for j in range(0,m):
          if i==j:
              D[i,j]= k_lim*d_[i]
          
  W = (2*V[0,:]**2)
  Wt = np.kron(W,W)

  r = k_lim*d_
  X_IG,Y_IG = np.meshgrid(r,r)

  return {'Wt': Wt, 'X_IG': X_IG, 'Y_IG': Y_IG, 'm_gauss': m}